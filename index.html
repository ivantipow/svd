<!DOCTYPE html>
<html>
<head>
    <title>Singular Value Decomposition for Image Compression</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .page-title {
            text-align: center;
            margin: 20px 0 30px;
            font-size: 28px;
            color: #1a237e;
            font-weight: 600;
        }

        .control-panel {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        /* Обновляем стили для контейнеров изображений */
        .canvas-container {
            position: relative;
            width: 100%; /* Занимаем всю доступную ширину */
            height: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8f9fa;
            min-height: 200px;
        }

        #originalCanvas, #compressedCanvas {
            display: none;
            width: 100% !important; /* Занимаем всю ширину контейнера */
            height: auto !important;
            max-height: 300px; /* Ограничиваем максимальную высоту */
            object-fit: contain;
            position: relative;
        }

        /* Обновляем стили для матриц */
        .matrices {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            flex-wrap: nowrap;
        }

        .matrix-container {
            flex: 1;
            width: calc(33% - 20px);
            min-width: 0;
            max-width: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #uMatrixCanvas, #sigmaMatrixCanvas, #vMatrixCanvas {
            display: none; /* Скрываем canvas изначально */
            width: 100%;
            height: auto !important;
            background-color: #f8f9fa;
            align-self: center;
        }

        .matrix-operator {
            font-size: 24px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            align-self: center;
        }

        .images-and-matrices {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: stretch;
            gap: 20px;
            margin-top: 10px;
        }

        .sub-block {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .sub-block h3 {
            margin: 0 0 15px 0;
            color: #1a237e;
            text-align: center;
            width: 100%;
        }

        .operator {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            padding: 0 10px;
            align-self: center;
        }

        .file-upload-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
        }

        .file-upload-container.hidden {
            display: none;
        }

        .file-upload-button {
            background-color: #1a237e;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .file-upload-button:hover {
            background-color: #283593;
        }

        input[type="file"] {
            display: none;
        }

        .theory-block {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 30px;
        }

        .theory-block h3 {
            color: #1a237e;
            margin-top: 0;
        }

        .author-link {
            text-align: center;
            margin: 40px auto 20px;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 300px;
        }

        .author-link a {
            color: #1a237e;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #singularValues {
            width: 400px;
            margin: 0;
        }

        .equals-sign, .approx-equals {
            font-size: 28px;
            margin: 0 10px;
        }

        .images {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        canvas {
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto;
        }

        /* Медиа-запросы для адаптивности */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }

            .slider-container {
                flex-direction: column;
            }

            #singularValues {
                width: 100%;
            }

            .images-and-matrices {
                flex-direction: column;
                align-items: center;
            }

            .images {
                flex-direction: column;
                align-items: center;
            }

            .approx-equals, .equals-sign {
                padding: 5px 0;
            }

            .svd-matrices {
                width: 100%;
            }

            .matrices {
                flex-direction: row; /* Оставляем горизонтальное расположение */
                flex-wrap: nowrap;
                gap: 5px; /* Уменьшаем отступы для мобильных устройств */
            }

            .matrix-operator {
                font-size: 18px; /* Уменьшаем размер операторов */
                margin: 0 2px;
            }

            #originalCanvas, #compressedCanvas {
                width: 150px;
                height: 100px;
            }

            .slider-wrapper {
                width: 100%;
            }
            
            .slider-ticks {
                font-size: 10px;
            }
        }

        /* Дополнительные стили для очень маленьких экранов */
        @media (max-width: 480px) {
            .page-title {
                font-size: 20px;
            }

            .theory-block {
                font-size: 14px;
            }
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loadingIndicator {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        #loadingStatus {
            color: #333;
            font-family: monospace;
            white-space: pre-line;
            line-height: 1.4;
        }
        .svd-matrices {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }
        .svd-formula {
            font-size: 20px;
            text-align: center;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
        }
        .matrix-container h4 {
            text-align: center;
            width: 100%;
            margin-bottom: 10px;
            align-self: center;
        }
        .matrix-dimensions {
            text-align: center;
            width: 100%;
            margin-top: 5px;
            font-family: monospace;
            align-self: center;
        }
        .language-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #1a237e;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .language-switch:hover {
            background-color: #283593;
        }

        .theory-block h4 {
            color: #1a237e;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        /* Добавляем новые стили */
        .slider-wrapper {
            position: relative;
            width: 400px;
            margin: 0;
        }

        .slider-ticks {
            display: flex;
            justify-content: space-between;
            padding: 0;
            margin-top: 2px;
            font-size: 12px;
            color: #666;
            position: relative;
            width: calc(100% - 16px);
            margin-left: 8px;
        }

        .slider-tick {
            position: relative;
            text-align: center;
            width: 0;
        }

        .slider-tick::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 0;
            transform: translateX(-50%);
            width: 1px;
            height: 4px;
            background-color: #666;
        }

        .slider-tick span {
            position: absolute;
            left: 0;
            transform: translateX(-50%);
            top: 1px;
        }
    </style>
</head>
<body>
    <button class="language-switch" onclick="toggleLanguage()">RU</button>
    <div class="container">
        <h1 class="page-title">Singular Value Decomposition for Image Compression</h1>
        
        <div class="control-panel">
            <div class="slider-container">
                <label for="singularValues">Количество собственных значений: </label>
                <div class="slider-wrapper">
                    <input type="range" id="singularValues" min="1" max="50" value="1" step="1">
                    <div class="slider-ticks">
                        <span class="slider-tick"><span>1</span></span>
                        <span class="slider-tick"><span>10</span></span>
                        <span class="slider-tick"><span>20</span></span>
                        <span class="slider-tick"><span>30</span></span>
                        <span class="slider-tick"><span>40</span></span>
                        <span class="slider-tick"><span>50</span></span>
                    </div>
                </div>
                <span id="singularValuesDisplay">1 компонента</span>
                <div id="loadingIndicator" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div class="spinner"></div>
                        <div id="loadingStatus">Подготовка к обработке...</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="images-and-matrices">
            <div class="sub-block">
                <h3>Оригинальное изображение</h3>
                <div class="canvas-container">
                <canvas id="originalCanvas"></canvas>
                    <div class="file-upload-container">
                        <label class="file-upload-button">
                            Загрузите изображение
                            <input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(event)">
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="operator">≈</div>
            
            <div class="sub-block">
                <h3>Сжатое изображение</h3>
                <div class="canvas-container">
                <canvas id="compressedCanvas"></canvas>
                </div>
            </div>
            
            <div class="operator">=</div>
            
            <div class="sub-block">
                <h3>Матрицы SVD разложения</h3>
                <div class="svd-formula">A ≈ U × Σ × V<sup>T</sup></div>
                <div class="matrices">
                    <div class="matrix-container">
                        <h4>U</h4>
                        <canvas id="uMatrixCanvas"></canvas>
                        <div id="uDimensions" class="matrix-dimensions"></div>
                    </div>
                    <div class="matrix-operator">×</div>
                    <div class="matrix-container">
                        <h4>Σ</h4>
                        <canvas id="sigmaMatrixCanvas"></canvas>
                        <div id="sigmaDimensions" class="matrix-dimensions"></div>
                    </div>
                    <div class="matrix-operator">×</div>
                    <div class="matrix-container">
                        <h4>V<sup>T</sup></h4>
                        <canvas id="vMatrixCanvas"></canvas>
                        <div id="vDimensions" class="matrix-dimensions"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="theory-block">
            <h3>Как это работает?</h3>
            <h4>Что такое SVD?</h4>
            <p>Сингулярное разложение (SVD) - это метод факторизации матрицы, который позволяет представить изображение в виде произведения трех матриц: U, Σ и V<sup>T</sup>. С интуицией, стоящей за сингулярным разложением, рекомендую ознакомиться в видео:</p>
            <div class="video-container">
                <iframe width="100%" height="315" src="https://www.youtube.com/embed/vSczTbgc8Rc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <h4 class="compression-title">Сжатие изображения</h4>
            <p>Процесс сжатия изображения с помощью SVD включает следующие шаги:</p>
            <ol>
                <li>Изображение представляется в виде матрицы для каждого цветового канала (R, G, B).</li>
                <li>Для каждой матрицы вычисляется SVD разложение: A = U × Σ × V<sup>T</sup></li>
                <li>Матрица Σ содержит сингулярные значения, упорядоченные по убыванию их значимости.</li>
                <li>Сжатие достигается путем использования только первых k компонент разложения.</li>
                <li>Чем больше компонент используется, тем точнее восстановленное изображение.</li>
            </ol>
            <p>Этот метод особенно эффективен для изображений с повторяющимися паттернами и плавными переходами цветов.</p>
        </div>

        <div class="author-link">Иван Антипов  
            (<a href="https://t.me/ai_about_ai" target="_blank">@ai_about_ai</a>)
        </div>

        <img id="originalImage" style="display: none;">
    </div>

    <script>
        let currentLanguage = 'en';

        const translations = {
            ru: {
                pageTitle: 'Сингулярное разложение для сжатия изображений',
                singularValuesLabel: 'Количество собственных значений:',
                loadingPrep: 'Подготовка к обработке...',
                uploadButton: 'Загрузите изображение',
                originalImage: 'Оригинальное изображение',
                compressedImage: 'Сжатое изображение',
                svdMatrices: 'Матрицы SVD разложения',
                howItWorks: 'Как это работает?',
                whatIsSvd: 'Что такое SVD?',
                svdDefinition: 'Сингулярное разложение (Singular Value Decomposition, SVD) — это метод линейной алгебры, который раскладывает любую матрицу A размером m × n на три компонента:<br>A = U × Σ × V<sup>T</sup><br>где:',
                svdComponents: [
                    'U и V — ортогональные матрицы,',
                    'Σ — диагональная матрица с сингулярными значениями, упорядоченными по убыванию.'
                ],
                singularValuesExplanation: 'Сингулярные значения (элементы Σ) отражают «важность» информации в данных: чем они больше, тем сильнее влияют на структуру матрицы A.',
                howToApplySvd: 'Как применить SVD к изображениям?',
                imageAsMatrix: 'Изображение в оттенках серого можно представить как матрицу, где каждый элемент — яркость пикселя (от 0 до 255). Цветное изображение — это три такие матрицы (для каналов Red, Green, Blue).',
                compressionIdea: 'Применяя SVD к матрице изображения, мы получаем набор сингулярных значений. <b>Идея сжатия</b>: оставить только k самых крупных сингулярных значений, а остальные отбросить. Это позволяет приближенно восстановить изображение с меньшим объемом данных.',
                compressionProcess: 'Процесс сжатия',
                compressionSteps: [
                    '<b>Разложение</b>: применяем SVD к матрице изображения.',
                    '<b>Усечение</b>: оставляем первые k сингулярных значений (остальные заменяем нулями).',
                    '<b>Восстановление</b>: умножаем усеченные матрицы U<sub>k</sub>, Σ<sub>k</sub>, V<sub>k</sub><sup>T</sup>, получая приближенную матрицу A<sub>k</sub> ≈ A.'
                ],
                sizeCalculation: '<b>Пример расчета размера</b>:',
                sizeCalculationSteps: [
                    'Исходное изображение: m × n пикселей.',
                    'После сжатия: храним U<sub>k</sub> (m × k), Σ<sub>k</sub> (k × k), V<sub>k</sub><sup>T</sup> (k × n).',
                    'Новый размер: k(m + n + 1). При k << m, n экономия значительна!'
                ],
                qualityCompressionBalance: 'Баланс между качеством и сжатием',
                balanceExplanation: 'Чем меньше k, тем выше степень сжатия, но ниже качество. На практике k выбирают экспериментально, в зависимости от допустимых потерь. Например, при k = 50 изображение может сохранить 90% информации, но занять в 10 раз меньше места.',
                authorName: 'Иван Антипов',
                processingStatus: {
                    scaling: 'Масштабирование изображения до 200px...',
                    rgbSplit: 'Разделение изображения на RGB каналы...',
                    normalization: 'Нормализация данных...',
                    computing: 'Вычисление компоненты',
                    error: 'Произошла ошибка при обработке изображения'
                },
                componentsOf: 'из',
                initialComponent: '1 компонента'
            },
            en: {
                pageTitle: 'Singular Value Decomposition for Image Compression',
                singularValuesLabel: 'Number of singular values:',
                loadingPrep: 'Preparing for processing...',
                uploadButton: 'Upload Image',
                originalImage: 'Original Image',
                compressedImage: 'Compressed Image',
                svdMatrices: 'SVD Decomposition Matrices',
                howItWorks: 'How It Works?',
                whatIsSvd: 'What is SVD?',
                svdDefinition: 'Singular Value Decomposition (SVD) is a linear algebra method that decomposes any matrix A of size m × n into three components:<br>A = U × Σ × V<sup>T</sup><br>where:',
                svdComponents: [
                    'U and V are orthogonal matrices,',
                    'Σ is a diagonal matrix with singular values ordered in descending order.'
                ],
                singularValuesExplanation: 'Singular values (elements of Σ) reflect the "importance" of information in the data: the larger they are, the stronger their influence on the structure of matrix A.',
                howToApplySvd: 'How to Apply SVD to Images?',
                imageAsMatrix: 'A grayscale image can be represented as a matrix where each element is a pixel brightness (from 0 to 255). A color image consists of three such matrices (for Red, Green, Blue channels).',
                compressionIdea: 'Applying SVD to the image matrix, we get a set of singular values. <b>Compression idea</b>: keep only k largest singular values and discard the rest. This allows approximate image reconstruction with less data.',
                compressionProcess: 'Compression Process',
                compressionSteps: [
                    '<b>Decomposition</b>: apply SVD to the image matrix.',
                    '<b>Truncation</b>: keep the first k singular values (replace others with zeros).',
                    '<b>Reconstruction</b>: multiply truncated matrices U<sub>k</sub>, Σ<sub>k</sub>, V<sub>k</sub><sup>T</sup> to get approximate matrix A<sub>k</sub> ≈ A.'
                ],
                sizeCalculation: '<b>Size Calculation Example</b>:',
                sizeCalculationSteps: [
                    'Original image: m × n pixels.',
                    'After compression: store U<sub>k</sub> (m × k), Σ<sub>k</sub> (k × k), V<sub>k</sub><sup>T</sup> (k × n).',
                    'New size: k(m + n + 1). When k << m, n the savings are significant!'
                ],
                qualityCompressionBalance: 'Balance Between Quality and Compression',
                balanceExplanation: 'The smaller k, the higher the compression ratio but lower the quality. In practice, k is chosen experimentally, depending on acceptable losses. For example, with k = 50, the image can retain 90% of information while taking up 10 times less space.',
                authorName: 'Ivan Antipov',
                processingStatus: {
                    scaling: 'Scaling image to 200px...',
                    rgbSplit: 'Splitting image into RGB channels...',
                    normalization: 'Normalizing data...',
                    computing: 'Computing component',
                    error: 'Error processing image'
                },
                componentsOf: 'of',
                initialComponent: '1 component'
            }
        };

        function toggleLanguage() {
            const button = document.querySelector('.language-switch');
            currentLanguage = currentLanguage === 'ru' ? 'en' : 'ru';
            button.textContent = currentLanguage === 'ru' ? 'RU' : 'EN';
            updatePageLanguage();
        }

        function updatePageLanguage() {
            const t = translations[currentLanguage];
            
            document.title = t.pageTitle;
            
            document.querySelector('.page-title').innerHTML = t.pageTitle;
            
            document.querySelector('label[for="singularValues"]').textContent = t.singularValuesLabel;
            
            document.getElementById('loadingStatus').textContent = t.loadingPrep;
            
            const fileUploadButton = document.querySelector('.file-upload-button');
            fileUploadButton.innerHTML = t.uploadButton + 
                '<input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(event)">';
            
            document.querySelectorAll('.sub-block h3').forEach((h3, index) => {
                if (index === 0) h3.textContent = t.originalImage;
                if (index === 1) h3.textContent = t.compressedImage;
                if (index === 2) h3.textContent = t.svdMatrices;
            });
            
            const theoryBlock = document.querySelector('.theory-block');
            theoryBlock.innerHTML = `
                <h3>${t.howItWorks}</h3>
                <h4>${t.whatIsSvd}</h4>
                <p>${t.svdDefinition}</p>
                <ul>
                    ${t.svdComponents.map(comp => `<li>${comp}</li>`).join('')}
                </ul>
                <p>${t.singularValuesExplanation}</p>
                
                <h4>${t.howToApplySvd}</h4>
                <p>${t.imageAsMatrix}</p>
                <p>${t.compressionIdea}</p>
                
                <h4>${t.compressionProcess}</h4>
                <ol>
                    ${t.compressionSteps.map(step => `<li>${step}</li>`).join('')}
                </ol>
                
                <p>${t.sizeCalculation}</p>
                <ul>
                    ${t.sizeCalculationSteps.map(step => `<li>${step}</li>`).join('')}
                </ul>
                
                <h4>${t.qualityCompressionBalance}</h4>
                <p>${t.balanceExplanation}</p>
            `;
            
            const authorLink = document.querySelector('.author-link');
            authorLink.innerHTML = `${t.authorName} (<a href="https://t.me/ai_about_ai" target="_blank">@ai_about_ai</a>)`;

            // Обновляем начальное значение слайдера
            const singularValuesDisplay = document.getElementById('singularValuesDisplay');
            if (!document.getElementById('originalImage').src) {
                singularValuesDisplay.textContent = t.initialComponent;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            updatePageLanguage();
            const singularValuesInput = document.getElementById('singularValues');
            const singularValuesDisplay = document.getElementById('singularValuesDisplay');
            
            let compressTimeout = null;
            
            function updateSliderMax(width, height) {
                const maxComponents = Math.min(50, Math.min(width, height));
                const t = translations[currentLanguage];
                singularValuesInput.max = maxComponents;
                singularValuesInput.value = 1;
                singularValuesDisplay.textContent = `1 ${t.componentsOf} ${maxComponents}`;
                console.log(`Максимальное количество компонент: ${maxComponents}`);
            }
            
            const originalImage = document.getElementById('originalImage');
            originalImage.onload = function() {
                const width = this.width;
                const height = this.height;
                updateSliderMax(width, height);
                drawOriginalImage(this);
                compressImage(this, 1);
            };
            
            singularValuesInput.addEventListener('input', function() {
                const value = parseInt(this.value);
                const max = parseInt(this.max);
                const t = translations[currentLanguage];
                singularValuesDisplay.textContent = `${value} ${t.componentsOf} ${max}`;
                
                if (compressTimeout) {
                    clearTimeout(compressTimeout);
                }
                
                if (svdResults.R.V.length > 0) {
                compressTimeout = setTimeout(() => {
                    const img = document.getElementById('originalImage');
                    if (img.src) {
                            updateCompressedImage(value);
                        }
                    }, 100);
                    }
            });
        });

        function handleImageUpload(event) {
            const fileInput = event.target;
            if (fileInput.files[0]) {
                document.getElementById('originalCanvas').style.display = 'block';
                document.getElementById('compressedCanvas').style.display = 'block';
                document.querySelector('.matrices').style.display = 'flex';
                
                document.getElementById('uMatrixCanvas').style.display = 'block';
                document.getElementById('sigmaMatrixCanvas').style.display = 'block';
                document.getElementById('vMatrixCanvas').style.display = 'block';
                
                document.querySelector('.file-upload-container').style.display = 'none';
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.getElementById('originalImage');
                    img.onload = function() {
                        const t = translations[currentLanguage].processingStatus;
                        updateLoadingStatus(t.scaling);
                        document.getElementById('loadingIndicator').style.display = 'block';
                        
                        drawOriginalImage(img);
                        
                        setTimeout(() => {
                        const singularValues = parseInt(document.getElementById('singularValues').value);
                        compressImage(img, singularValues)
                                .catch(error => {
                                    console.error('Ошибка при сжатии:', error);
                                    updateLoadingStatus(t.error);
                                });
                        }, 0);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(fileInput.files[0]);
            }
        }
        function drawOriginalImage(img) {
            const maxSize = 200;
            let width = img.width;
            let height = img.height;
            
                const ratio = Math.min(maxSize / width, maxSize / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            
            originalCanvas.width = width;
            originalCanvas.height = height;
            compressedCanvas.width = width;
            compressedCanvas.height = height;
            
            const ctx = originalCanvas.getContext('2d', { willReadFrequently: true });
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, width, height);
            
            originalCanvas.style.maxWidth = '100%';
            originalCanvas.style.maxHeight = '100%';
            compressedCanvas.style.maxWidth = '100%';
            compressedCanvas.style.maxHeight = '100%';
        }
        function showCompressionInfo(originalSize, k) {
            const compressionRatio = ((originalSize - k) / originalSize * 100).toFixed(2);
            console.log(`Степень сжатия: ${compressionRatio}%`);
            console.log(`Использовано компонент: ${k}`);
        }

        document.getElementById('singularValues').addEventListener('input', function() {
            const img = document.getElementById('originalImage');
            if (img.src) {
                compressImage(img, parseInt(this.value))
                    .catch(error => console.error('Ошибка при сжатии:', error));
            }
        });

        let svdResults = {
            R: { V: [], covMatrix: null, mean: null },
            G: { V: [], covMatrix: null, mean: null },
            B: { V: [], covMatrix: null, mean: null }
        };

        function updateLoadingStatus(status) {
            const t = translations[currentLanguage].processingStatus;
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingStatus = document.getElementById('loadingStatus');
            
            loadingIndicator.style.display = 'block';
            loadingStatus.textContent = status.startsWith('Computing') ? 
                `${t.computing} ${status.split(' ')[2]}...` : t[status.toLowerCase()];
        }

        async function performInitialSVD(matrix, channel) {
                const normalizedMatrix = matrix.div(255.0);
                const mean = normalizedMatrix.mean(0);
                const centeredMatrix = normalizedMatrix.sub(mean);
            const covMatrix = tf.matMul(centeredMatrix.transpose(), centeredMatrix).div(matrix.shape[0]);
            
            svdResults[channel] = {
                V: [],
                mean: mean.clone(),
                centeredMatrix: centeredMatrix.clone(),
                covMatrix: covMatrix.clone()
            };
            
            return {
                covMatrix,
                shape: matrix.shape[1]
            };
        }

        async function computeNextComponent(channel, covMatrix, shape) {
            let v = tf.randomNormal([shape, 1]);
            const V = svdResults[channel].V;
                    
                    for (let iter = 0; iter < 20; iter++) {
                        v = tf.matMul(covMatrix, v);
                        const norm = tf.norm(v);
                        v = v.div(norm.add(1e-10));
                        
                        if (V.length > 0) {
                            for (let j = 0; j < V.length; j++) {
                                const proj = tf.sum(v.mul(V[j]));
                                v = v.sub(V[j].mul(proj));
                            }
                            const normAfterProj = tf.norm(v);
                            v = v.div(normAfterProj.add(1e-10));
                        }
                    }
            
            svdResults[channel].V.push(v.clone());
        }

        async function updateCompressedImage(k) {
            try {
                const tempCanvas = document.createElement('canvas');
                const width = originalCanvas.width;
                const height = originalCanvas.height;
                tempCanvas.width = width;
                tempCanvas.height = height;
                
                const compressedR = await reconstructImage('R', k);
                const compressedG = await reconstructImage('G', k);
                const compressedB = await reconstructImage('B', k);

                const [rArray, gArray, bArray] = await Promise.all([
                    compressedR.array(),
                    compressedG.array(),
                    compressedB.array()
                ]);

                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                const imageData = tempCtx.createImageData(width, height);

                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const idx = (i * width + j) * 4;
                        imageData.data[idx] = Math.round(rArray[i][j]);
                        imageData.data[idx + 1] = Math.round(gArray[i][j]);
                        imageData.data[idx + 2] = Math.round(bArray[i][j]);
                        imageData.data[idx + 3] = 255;
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);

                compressedCanvas.width = width;
                compressedCanvas.height = height;
                const compressedCtx = compressedCanvas.getContext('2d');
                compressedCtx.drawImage(tempCanvas, 0, 0);

                await visualizeSVDMatrices(k);

                compressedCanvas.style.maxWidth = '100%';
                compressedCanvas.style.maxHeight = '100%';
            } catch (error) {
                console.error('Ошибка при обновлении изображения:', error);
                updateLoadingStatus('Ошибка при обновлении изображения');
            }
        }

        async function reconstructImage(channel, k) {
            console.log(`Реконструкция канала ${channel} с k=${k}`);
            return tf.tidy(() => {
                const { V, mean, centeredMatrix } = svdResults[channel];
                console.log(`[${channel}] Данные получены, начало реконструкции`);
                
                if (k <= 0 || k > V.length) {
                    console.error(`Некорректное количество компонент: ${k}. Доступно: ${V.length}`);
                    return tf.zeros(centeredMatrix.shape);
                }

                const components = V.slice(0, k);
                if (components.length === 0) {
                    console.error('Нет компонент для реконструкции');
                    return tf.zeros(centeredMatrix.shape);
                }

                const basisMatrix = tf.concat(components, 1);
                const scores = tf.matMul(centeredMatrix, basisMatrix);
                const reconstruction = tf.matMul(scores, basisMatrix.transpose());
                const result = reconstruction.add(mean);
                
                console.log(`[${channel}] Реконструкция завершена`);
                return result.mul(255.0).clipByValue(0, 255);
            });
        }

        let processingTimeout = null;

        function resizeImage(img, maxSize) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            let width = img.width;
            let height = img.height;
            
            if (width > height && width > maxSize) {
                height = Math.round(height * (maxSize / width));
                width = maxSize;
            } else if (height > maxSize) {
                width = Math.round(width * (maxSize / height));
                height = maxSize;
            }
            
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            tempCtx.drawImage(img, 0, 0, width, height);
            
            return tempCtx.getImageData(0, 0, width, height);
        }

        async function compressImage(img, singularValues) {
            try {
                const width = originalCanvas.width;
                const height = originalCanvas.height;
                console.log('Размеры изображения:', { width, height });
                
                const ctx = originalCanvas.getContext('2d', { willReadFrequently: true });
                const imageData = ctx.getImageData(0, 0, width, height);
                
                if (!svdResults.R.V.length) {
                    updateLoadingStatus('Разделение изображения на RGB каналы...');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const [r, g, b] = separateChannels(imageData);
                    
                    updateLoadingStatus('Нормализация данных...');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const rTensor = tf.tensor2d(r, [height, width]);
                    const gTensor = tf.tensor2d(g, [height, width]);
                    const bTensor = tf.tensor2d(b, [height, width]);

                    const [rInit, gInit, bInit] = await Promise.all([
                        performInitialSVD(rTensor, 'R'),
                        performInitialSVD(gTensor, 'G'),
                        performInitialSVD(bTensor, 'B')
                    ]);

                    const maxK = Math.min(50, Math.min(width, height));
                    
                    for (let i = 0; i < maxK; i++) {
                        updateLoadingStatus(`Вычисление компоненты ${i + 1} из ${maxK}...`);
                        
                        await Promise.all([
                            computeNextComponent('R', rInit.covMatrix, rInit.shape),
                            computeNextComponent('G', gInit.covMatrix, gInit.shape),
                            computeNextComponent('B', bInit.covMatrix, bInit.shape)
                        ]);

                        const currentK = i + 1;
                        const singularValuesInput = document.getElementById('singularValues');
                        const singularValuesDisplay = document.getElementById('singularValuesDisplay');
                        const t = translations[currentLanguage];

                        singularValuesInput.value = currentK;
                        singularValuesDisplay.textContent = `${currentK} ${t.componentsOf} ${maxK}`;
                        
                        await updateCompressedImage(currentK);
                        
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }

                    document.getElementById('loadingIndicator').style.display = 'none';
                } else {
                    await updateCompressedImage(singularValues);
                }

            } catch (error) {
                console.error('Ошибка при сжатии:', error);
                updateLoadingStatus('Ошибка при обработке изображения');
            }
        }

        function separateChannels(imageData) {
            const r = new Float32Array(imageData.width * imageData.height);
            const g = new Float32Array(imageData.width * imageData.height);
            const b = new Float32Array(imageData.width * imageData.height);
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const idx = i / 4;
                    r[idx] = imageData.data[i];
                    g[idx] = imageData.data[i + 1];
                    b[idx] = imageData.data[i + 2];
                }

            return [r, g, b];
        }

        function visualizeMatrix(canvas, dataR, dataG, dataB, width, height, fullWidth, fullHeight, drawBorder = false) {
            canvas.width = fullWidth;
            canvas.height = fullHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, fullWidth, fullHeight);
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            const imageData = tempCtx.createImageData(width, height);
            
            let min = Infinity;
            let max = -Infinity;
            for (let i = 0; i < dataR.length; i++) {
                min = Math.min(min, dataR[i], dataG[i], dataB[i]);
                max = Math.max(max, dataR[i], dataG[i], dataB[i]);
            }
            
            for (let i = 0; i < dataR.length; i++) {
                const normalizedR = (dataR[i] - min) / (max - min);
                const normalizedG = (dataG[i] - min) / (max - min);
                const normalizedB = (dataB[i] - min) / (max - min);
                
                const idx = i * 4;
                imageData.data[idx] = Math.round(normalizedR * 255);
                imageData.data[idx + 1] = Math.round(normalizedG * 255);
                imageData.data[idx + 2] = Math.round(normalizedB * 255);
                imageData.data[idx + 3] = 255;
            }
            
            tempCtx.putImageData(imageData, 0, 0);
            
            ctx.drawImage(tempCanvas, 0, 0);

            if (drawBorder) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, fullWidth, fullHeight);

                ctx.strokeStyle = '#666';
                ctx.setLineDash([2, 2]);
                ctx.strokeRect(0, 0, width, height);
                
                if (fullWidth === fullHeight) {
                    ctx.beginPath();
                    ctx.setLineDash([2, 2]);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(fullWidth, fullHeight);
                    ctx.stroke();
                }
            }
        }

        async function visualizeSVDMatrices(k) {
            const { V: VR, centeredMatrix: centeredMatrixR } = svdResults.R;
            const { V: VG, centeredMatrix: centeredMatrixG } = svdResults.G;
            const { V: VB, centeredMatrix: centeredMatrixB } = svdResults.B;
            
            if (!VR.length) return;

            const height = centeredMatrixR.shape[0];
            const width = centeredMatrixR.shape[1];
            const maxK = Math.min(50, Math.min(width, height));

            const processChannel = async (V, centeredMatrix) => {
                const components = V.slice(0, k);
                const basisMatrix = tf.concat(components, 1);
                
                const U = tf.matMul(centeredMatrix, basisMatrix);
                
                const sigma = await Promise.all(components.map(async (v) => {
                    const norm = await tf.norm(tf.matMul(centeredMatrix, v)).array();
                    return norm;
                }));

                const uData = await U.array();
                const vData = await tf.concat(components, 1).transpose().array();

                return {
                    U: uData.flat(),
                    sigma,
                    V: vData.flat()
                };
            };

            const [dataR, dataG, dataB] = await Promise.all([
                processChannel(VR, centeredMatrixR),
                processChannel(VG, centeredMatrixG),
                processChannel(VB, centeredMatrixB)
            ]);

            const uCanvas = document.getElementById('uMatrixCanvas');
            const sigmaCanvas = document.getElementById('sigmaMatrixCanvas');
            const vCanvas = document.getElementById('vMatrixCanvas');

            visualizeMatrix(uCanvas, dataR.U, dataG.U, dataB.U, k, height, maxK, height, true);
            
            const sigmaSize = k;
            const sigmaMatrixR = new Float32Array(sigmaSize * sigmaSize);
            const sigmaMatrixG = new Float32Array(sigmaSize * sigmaSize);
            const sigmaMatrixB = new Float32Array(sigmaSize * sigmaSize);
            
            for (let i = 0; i < k; i++) {
                sigmaMatrixR[i * sigmaSize + i] = dataR.sigma[i];
                sigmaMatrixG[i * sigmaSize + i] = dataG.sigma[i];
                sigmaMatrixB[i * sigmaSize + i] = dataB.sigma[i];
            }
            
            visualizeMatrix(sigmaCanvas, sigmaMatrixR, sigmaMatrixG, sigmaMatrixB, 
                k, k, maxK, maxK, true);
            
            visualizeMatrix(vCanvas, dataR.V, dataG.V, dataB.V, width, k, width, maxK, true);

            function updateDimensions(elementId, width, height, fullWidth, fullHeight) {
                const dimensionsDiv = document.getElementById(elementId);
                if (elementId === 'sigmaDimensions') {
                    dimensionsDiv.innerHTML = `${width}`;
                } else {
                    dimensionsDiv.innerHTML = `${height}×${width}`;
                }
            }

            updateDimensions('uDimensions', k, height, maxK, height);
            updateDimensions('sigmaDimensions', k, k, maxK, maxK);
            updateDimensions('vDimensions', width, k, width, maxK);
        }
    </script>
</body>
</html>

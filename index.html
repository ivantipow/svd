<!DOCTYPE html>
<html>
<head>
    <title>Singular Value Decomposition for Image Compression</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .page-title {
            text-align: center;
            margin: 20px 0 30px;
            font-size: 28px;
            color: #1a237e;
            font-weight: 600;
        }

        .control-panel {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        /* Обновляем стили для контейнеров изображений */
        .canvas-container {
            position: relative;
            width: 100%; /* Занимаем всю доступную ширину */
            height: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8f9fa;
            min-height: 200px;
        }

        #originalCanvas, #compressedCanvas {
            display: none;
            width: 100% !important; /* Занимаем всю ширину контейнера */
            height: auto !important;
            max-height: 300px; /* Ограничиваем максимальную высоту */
            object-fit: contain;
            position: relative;
        }

        /* Обновляем стили для матриц */
        .matrices {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            flex-wrap: nowrap;
        }

        .matrix-container {
            flex: 1;
            width: calc(33% - 20px);
            min-width: 0;
            max-width: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #uMatrixCanvas, #sigmaMatrixCanvas, #vMatrixCanvas {
            display: none; /* Скрываем canvas изначально */
            width: 100%;
            height: auto !important;
            background-color: #f8f9fa;
            align-self: center;
        }

        .matrix-operator {
            font-size: 24px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            align-self: center;
        }

        .images-and-matrices {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: stretch;
            gap: 20px;
            margin-top: 10px;
        }

        .sub-block {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .sub-block h3 {
            margin: 0 0 15px 0;
            color: #1a237e;
            text-align: center;
            width: 100%;
        }

        .operator {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            padding: 0 10px;
            align-self: center;
        }

        .file-upload-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
        }

        .file-upload-container.hidden {
            display: none;
        }

        .file-upload-button {
            background-color: #1a237e;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .file-upload-button:hover {
            background-color: #283593;
        }

        input[type="file"] {
            display: none;
        }

        .theory-block {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 30px;
        }

        .theory-block h3 {
            color: #1a237e;
            margin-top: 0;
        }

        .author-link {
            text-align: center;
            margin: 40px auto 20px;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 300px;
        }

        .author-link a {
            color: #1a237e;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #singularValues {
            width: 200px;
            margin: 0;
        }

        .equals-sign, .approx-equals {
            font-size: 28px;
            margin: 0 10px;
        }

        .images {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        canvas {
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto;
        }

        /* Медиа-запросы для адаптивности */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }

            .slider-container {
                flex-direction: column;
            }

            #singularValues {
                width: 100%;
            }

            .images-and-matrices {
                flex-direction: column;
                align-items: center;
            }

            .images {
                flex-direction: column;
                align-items: center;
            }

            .approx-equals, .equals-sign {
                padding: 5px 0;
            }

            .svd-matrices {
                width: 100%;
            }

            .matrices {
                flex-direction: row; /* Оставляем горизонтальное расположение */
                flex-wrap: nowrap;
                gap: 5px; /* Уменьшаем отступы для мобильных устройств */
            }

            .matrix-operator {
                font-size: 18px; /* Уменьшаем размер операторов */
                margin: 0 2px;
            }

            #originalCanvas, #compressedCanvas {
                width: 150px;
                height: 100px;
            }
        }

        /* Дополнительные стили для очень маленьких экранов */
        @media (max-width: 480px) {
            .page-title {
                font-size: 20px;
            }

            .theory-block {
                font-size: 14px;
            }
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loadingIndicator {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        #loadingStatus {
            color: #333;
            font-family: monospace;
            white-space: pre-line;
            line-height: 1.4;
        }
        .svd-matrices {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }
        .svd-formula {
            font-size: 20px;
            text-align: center;
            margin: 10px 0;
            font-family: 'Times New Roman', serif;
        }
        .matrix-container h4 {
            text-align: center;
            width: 100%;
            margin-bottom: 10px;
            align-self: center;
        }
        .matrix-dimensions {
            text-align: center;
            width: 100%;
            margin-top: 5px;
            font-family: monospace;
            align-self: center;
        }
        .language-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #1a237e;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .language-switch:hover {
            background-color: #283593;
        }
    </style>
</head>
<body>
    <button class="language-switch" onclick="toggleLanguage()">RU</button>
    <div class="container">
        <h1 class="page-title">Singular Value Decomposition for Image Compression</h1>
        
        <div class="control-panel">
            <div class="slider-container">
                <label for="singularValues">Количество собственных значений: </label>
                <input type="range" id="singularValues" min="1" max="50" value="1" step="1">
                <span id="singularValuesDisplay">1 компонента</span>
                <div id="loadingIndicator" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div class="spinner"></div>
                        <div id="loadingStatus">Подготовка к обработке...</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="images-and-matrices">
            <div class="sub-block">
                <h3>Оригинальное изображение</h3>
                <div class="canvas-container">
                <canvas id="originalCanvas"></canvas>
                    <div class="file-upload-container">
                        <label class="file-upload-button">
                            Загрузите изображение
                            <input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(event)">
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="operator">≈</div>
            
            <div class="sub-block">
                <h3>Сжатое изображение</h3>
                <div class="canvas-container">
                <canvas id="compressedCanvas"></canvas>
                </div>
            </div>
            
            <div class="operator">=</div>
            
            <div class="sub-block">
                <h3>Матрицы SVD разложения</h3>
                <div class="svd-formula">A ≈ U × Σ × V<sup>T</sup></div>
                <div class="matrices">
                    <div class="matrix-container">
                        <h4>U</h4>
                        <canvas id="uMatrixCanvas"></canvas>
                        <div id="uDimensions" class="matrix-dimensions"></div>
                    </div>
                    <div class="matrix-operator">×</div>
                    <div class="matrix-container">
                        <h4>Σ</h4>
                        <canvas id="sigmaMatrixCanvas"></canvas>
                        <div id="sigmaDimensions" class="matrix-dimensions"></div>
                    </div>
                    <div class="matrix-operator">×</div>
                    <div class="matrix-container">
                        <h4>V<sup>T</sup></h4>
                        <canvas id="vMatrixCanvas"></canvas>
                        <div id="vDimensions" class="matrix-dimensions"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="theory-block">
            <h3>Как это работает?</h3>
            <p>Сингулярное разложение (SVD) - это метод факторизации матрицы, который позволяет представить изображение в виде произведения трех матриц: U, Σ и V<sup>T</sup>. С интуицией, стоящей за сингулярным разложением, рекомендую ознакомиться в видео:</p>
            <div class="video-container">
                <iframe width="100%" height="315" src="https://www.youtube.com/embed/vSczTbgc8Rc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <h4 class="compression-title">Сжатие изображения</h4>
            <p>Процесс сжатия изображения с помощью SVD включает следующие шаги:</p>
            <ol>
                <li>Изображение представляется в виде матрицы для каждого цветового канала (R, G, B).</li>
                <li>Для каждой матрицы вычисляется SVD разложение: A = U × Σ × V<sup>T</sup></li>
                <li>Матрица Σ содержит сингулярные значения, упорядоченные по убыванию их значимости.</li>
                <li>Сжатие достигается путем использования только первых k компонент разложения.</li>
                <li>Чем больше компонент используется, тем точнее восстановленное изображение.</li>
            </ol>
            <p>Этот метод особенно эффективен для изображений с повторяющимися паттернами и плавными переходами цветов.</p>
        </div>

        <div class="author-link">Иван Антипов  
            (<a href="https://t.me/ai_about_ai" target="_blank">@ai_about_ai</a>)
        </div>

        <img id="originalImage" style="display: none;">
    </div>

    <script>
        let currentLanguage = 'en';

        const translations = {
            ru: {
                pageTitle: 'Сингулярное разложение для сжатия изображений',
                singularValuesLabel: 'Количество собственных значений:',
                loadingPrep: 'Подготовка к обработке...',
                uploadButton: 'Загрузите изображение',
                originalImage: 'Оригинальное изображение',
                compressedImage: 'Сжатое изображение',
                svdMatrices: 'Матрицы SVD разложения',
                howItWorks: 'Как это работает?',
                theory: 'Сингулярное разложение (SVD) - это метод факторизации матрицы, который позволяет представить изображение в виде произведения трех матриц: U, Σ и V<sup>T</sup>. Подробнее об интуиции, стоящей за сингулярным разложением, рекомендую ознакомиться в видео:',
                imageCompression: 'Сжатие изображения',
                stepsIntro: 'Процесс сжатия изображения с помощью SVD включает следующие шаги:',
                steps: [
                    'Изображение представляется в виде матрицы для каждого цветового канала (R, G, B).',
                    'Для каждой матрицы вычисляется SVD разложение: A = U × Σ × V<sup>T</sup>',
                    'Матрица Σ содержит сингулярные значения, упорядоченные по убыванию их значимости.',
                    'Сжатие достигается путем использования только первых k компонент разложения.',
                    'Чем больше компонент используется, тем точнее восстановленное изображение.'
                ],
                effectiveFor: 'Этот метод особенно эффективен для изображений с повторяющимися паттернами и плавными переходами цветов.',
                components: 'компонента',
                componentsOf: 'из',
                processingStatus: {
                    scaling: 'Масштабирование изображения до 200px...',
                    rgbSplit: 'Разделение изображения на RGB каналы...',
                    normalization: 'Нормализация данных...',
                    computing: 'Вычисление компоненты'
                },
                errors: {
                    compression: 'Ошибка при сжатии',
                    processing: 'Ошибка при обработке изображения',
                    updating: 'Ошибка при обновлении изображения'
                },
                authorName: 'Иван Антипов'
            },
            en: {
                pageTitle: 'Singular Value Decomposition for Image Compression',
                singularValuesLabel: 'Number of singular values:',
                loadingPrep: 'Preparing for processing...',
                uploadButton: 'Upload Image',
                originalImage: 'Original Image',
                compressedImage: 'Compressed Image',
                svdMatrices: 'SVD Decomposition Matrices',
                howItWorks: 'How It Works?',
                theory: 'Singular Value Decomposition (SVD) is a matrix factorization method that allows representing an image as a product of three matrices: U, Σ, and V<sup>T</sup>. For more details about the intuition behind singular value decomposition, I recommend watching this video:',
                imageCompression: 'Image Compression',
                stepsIntro: 'The image compression process using SVD includes the following steps:',
                steps: [
                    'The image is represented as a matrix for each color channel (R, G, B).',
                    'SVD decomposition is calculated for each matrix: A = U × Σ × V<sup>T</sup>',
                    'Matrix Σ contains singular values ordered by decreasing significance.',
                    'Compression is achieved by using only the first k components of decomposition.',
                    'The more components used, the more accurate the reconstructed image.'
                ],
                effectiveFor: 'This method is particularly effective for images with repeating patterns and smooth color transitions.',
                components: 'component',
                componentsOf: 'of',
                processingStatus: {
                    scaling: 'Scaling image to 200px...',
                    rgbSplit: 'Splitting image into RGB channels...',
                    normalization: 'Normalizing data...',
                    computing: 'Computing component'
                },
                errors: {
                    compression: 'Compression error',
                    processing: 'Error processing image',
                    updating: 'Error updating image'
                },
                authorName: 'Ivan Antipov'
            }
        };

        function toggleLanguage() {
            const button = document.querySelector('.language-switch');
            currentLanguage = currentLanguage === 'ru' ? 'en' : 'ru';
            button.textContent = currentLanguage === 'ru' ? 'RU' : 'EN';
            updatePageLanguage();
        }

        function updatePageLanguage() {
            const t = translations[currentLanguage];
            
            document.title = t.pageTitle;
            
            document.querySelector('.page-title').innerHTML = t.pageTitle;
            
            document.querySelector('label[for="singularValues"]').textContent = t.singularValuesLabel;
            
            document.getElementById('loadingStatus').textContent = t.loadingPrep;
            
            const fileUploadButton = document.querySelector('.file-upload-button');
            fileUploadButton.innerHTML = t.uploadButton + 
                '<input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(event)">';
            
            document.querySelectorAll('.sub-block h3').forEach((h3, index) => {
                if (index === 0) h3.textContent = t.originalImage;
                if (index === 1) h3.textContent = t.compressedImage;
                if (index === 2) h3.textContent = t.svdMatrices;
            });
            
            const theoryBlock = document.querySelector('.theory-block');
            theoryBlock.querySelector('h3').textContent = t.howItWorks;
            
            const firstP = theoryBlock.querySelector('p');
            firstP.innerHTML = t.theory;
            
            let videoContainer = theoryBlock.querySelector('.video-container');
            if (!videoContainer) {
                videoContainer = document.createElement('div');
                videoContainer.className = 'video-container';
                videoContainer.style.margin = '20px 0';
                videoContainer.innerHTML = '<iframe width="100%" height="315" src="https://www.youtube.com/embed/vSczTbgc8Rc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>';
                firstP.after(videoContainer);
            }
            
            let compressionTitle = theoryBlock.querySelector('.compression-title');
            if (!compressionTitle) {
                compressionTitle = document.createElement('h4');
                compressionTitle.className = 'compression-title';
                compressionTitle.style.color = '#1a237e';
                compressionTitle.style.marginTop = '30px';
                videoContainer.after(compressionTitle);
            }
            compressionTitle.textContent = t.imageCompression;
            
            theoryBlock.querySelectorAll('p')[1].textContent = t.stepsIntro;
            
            const steps = theoryBlock.querySelectorAll('ol li');
            steps.forEach((step, index) => {
                step.innerHTML = t.steps[index];
            });
            
            theoryBlock.querySelectorAll('p')[2].textContent = t.effectiveFor;
            
            const value = document.getElementById('singularValues').value;
            const max = document.getElementById('singularValues').max;
            document.getElementById('singularValuesDisplay').textContent = 
                `${value} ${t.componentsOf} ${max}`;
            
            const authorLink = document.querySelector('.author-link');
            authorLink.innerHTML = `${t.authorName} (<a href="https://t.me/ai_about_ai" target="_blank">@ai_about_ai</a>)`;
        }

        document.addEventListener('DOMContentLoaded', function() {
            updatePageLanguage();
            const singularValuesInput = document.getElementById('singularValues');
            const singularValuesDisplay = document.getElementById('singularValuesDisplay');
            
            let compressTimeout = null;
            
            function updateSliderMax(width, height) {
                const maxComponents = Math.min(50, Math.min(width, height));
                const t = translations[currentLanguage];
                singularValuesInput.max = maxComponents;
                singularValuesInput.value = 1;
                singularValuesDisplay.textContent = `1 ${t.componentsOf} ${maxComponents}`;
                console.log(`Максимальное количество компонент: ${maxComponents}`);
            }
            
            const originalImage = document.getElementById('originalImage');
            originalImage.onload = function() {
                const width = this.width;
                const height = this.height;
                updateSliderMax(width, height);
                drawOriginalImage(this);
                compressImage(this, 1);
            };
            
            singularValuesInput.addEventListener('input', function() {
                const value = parseInt(this.value);
                const max = parseInt(this.max);
                const t = translations[currentLanguage];
                singularValuesDisplay.textContent = `${value} ${t.componentsOf} ${max}`;
                
                if (compressTimeout) {
                    clearTimeout(compressTimeout);
                }
                
                if (svdResults.R.V.length > 0) {
                    compressTimeout = setTimeout(() => {
                        const img = document.getElementById('originalImage');
                        if (img.src) {
                            updateCompressedImage(value);
                        }
                    }, 100);
                }
            });
        });

        function handleImageUpload(event) {
            const fileInput = event.target;
            if (fileInput.files[0]) {
                document.getElementById('originalCanvas').style.display = 'block';
                document.getElementById('compressedCanvas').style.display = 'block';
                document.querySelector('.matrices').style.display = 'flex';
                
                document.getElementById('uMatrixCanvas').style.display = 'block';
                document.getElementById('sigmaMatrixCanvas').style.display = 'block';
                document.getElementById('vMatrixCanvas').style.display = 'block';
                
                document.querySelector('.file-upload-container').style.display = 'none';
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.getElementById('originalImage');
                    img.onload = function() {
                        updateLoadingStatus('Масштабирование изображения до 200px...');
                        document.getElementById('loadingIndicator').style.display = 'block';
                        
                        drawOriginalImage(img);
                        
                        setTimeout(() => {
                        const singularValues = parseInt(document.getElementById('singularValues').value);
                        compressImage(img, singularValues)
                                .catch(error => {
                                    console.error('Ошибка при сжатии:', error);
                                    updateLoadingStatus('Произошла ошибка при обработке изображения');
                                });
                        }, 0);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(fileInput.files[0]);
            }
        }
        function drawOriginalImage(img) {
            const maxSize = 200;
            let width = img.width;
            let height = img.height;
            
            const ratio = Math.min(maxSize / width, maxSize / height);
            width = Math.floor(width * ratio);
            height = Math.floor(height * ratio);
            
            originalCanvas.width = width;
            originalCanvas.height = height;
            compressedCanvas.width = width;
            compressedCanvas.height = height;
            
            const ctx = originalCanvas.getContext('2d', { willReadFrequently: true });
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, width, height);
            
            originalCanvas.style.maxWidth = '100%';
            originalCanvas.style.maxHeight = '100%';
            compressedCanvas.style.maxWidth = '100%';
            compressedCanvas.style.maxHeight = '100%';
        }
        function showCompressionInfo(originalSize, k) {
            const compressionRatio = ((originalSize - k) / originalSize * 100).toFixed(2);
            console.log(`Степень сжатия: ${compressionRatio}%`);
            console.log(`Использовано компонент: ${k}`);
        }

        document.getElementById('singularValues').addEventListener('input', function() {
            const img = document.getElementById('originalImage');
            if (img.src) {
                compressImage(img, parseInt(this.value))
                    .catch(error => console.error('Ошибка при сжатии:', error));
            }
        });

        let svdResults = {
            R: { V: [], covMatrix: null, mean: null },
            G: { V: [], covMatrix: null, mean: null },
            B: { V: [], covMatrix: null, mean: null }
        };

        function updateLoadingStatus(status) {
            const t = translations[currentLanguage].processingStatus;
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingStatus = document.getElementById('loadingStatus');
            
            loadingIndicator.style.display = 'block';
            loadingStatus.textContent = status.startsWith('Computing') ? 
                `${t.computing} ${status.split(' ')[2]}...` : t[status.toLowerCase()];
        }

        async function performInitialSVD(matrix, channel) {
                const normalizedMatrix = matrix.div(255.0);
                const mean = normalizedMatrix.mean(0);
                const centeredMatrix = normalizedMatrix.sub(mean);
            const covMatrix = tf.matMul(centeredMatrix.transpose(), centeredMatrix).div(matrix.shape[0]);
            
            svdResults[channel] = {
                V: [],
                mean: mean.clone(),
                centeredMatrix: centeredMatrix.clone(),
                covMatrix: covMatrix.clone()
            };
            
            return {
                covMatrix,
                shape: matrix.shape[1]
            };
        }

        async function computeNextComponent(channel, covMatrix, shape) {
            let v = tf.randomNormal([shape, 1]);
            const V = svdResults[channel].V;
                    
                    for (let iter = 0; iter < 20; iter++) {
                        v = tf.matMul(covMatrix, v);
                        const norm = tf.norm(v);
                        v = v.div(norm.add(1e-10));
                        
                        if (V.length > 0) {
                            for (let j = 0; j < V.length; j++) {
                                const proj = tf.sum(v.mul(V[j]));
                                v = v.sub(V[j].mul(proj));
                            }
                            const normAfterProj = tf.norm(v);
                            v = v.div(normAfterProj.add(1e-10));
                        }
                    }
            
            svdResults[channel].V.push(v.clone());
        }

        async function updateCompressedImage(k) {
            try {
                const tempCanvas = document.createElement('canvas');
                const width = originalCanvas.width;
                const height = originalCanvas.height;
                tempCanvas.width = width;
                tempCanvas.height = height;
                
                const compressedR = await reconstructImage('R', k);
                const compressedG = await reconstructImage('G', k);
                const compressedB = await reconstructImage('B', k);

                const [rArray, gArray, bArray] = await Promise.all([
                    compressedR.array(),
                    compressedG.array(),
                    compressedB.array()
                ]);

                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                const imageData = tempCtx.createImageData(width, height);

                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const idx = (i * width + j) * 4;
                        imageData.data[idx] = Math.round(rArray[i][j]);
                        imageData.data[idx + 1] = Math.round(gArray[i][j]);
                        imageData.data[idx + 2] = Math.round(bArray[i][j]);
                        imageData.data[idx + 3] = 255;
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);

                compressedCanvas.width = width;
                compressedCanvas.height = height;
                const compressedCtx = compressedCanvas.getContext('2d');
                compressedCtx.drawImage(tempCanvas, 0, 0);

                await visualizeSVDMatrices(k);

                compressedCanvas.style.maxWidth = '100%';
                compressedCanvas.style.maxHeight = '100%';
            } catch (error) {
                console.error('Ошибка при обновлении изображения:', error);
                updateLoadingStatus('Ошибка при обновлении изображения');
            }
        }

        async function reconstructImage(channel, k) {
            console.log(`Реконструкция канала ${channel} с k=${k}`);
            return tf.tidy(() => {
                const { V, mean, centeredMatrix } = svdResults[channel];
                console.log(`[${channel}] Данные получены, начало реконструкции`);
                
                if (k <= 0 || k > V.length) {
                    console.error(`Некорректное количество компонент: ${k}. Доступно: ${V.length}`);
                    return tf.zeros(centeredMatrix.shape);
                }

                const components = V.slice(0, k);
                if (components.length === 0) {
                    console.error('Нет компонент для реконструкции');
                    return tf.zeros(centeredMatrix.shape);
                }

                const basisMatrix = tf.concat(components, 1);
                const scores = tf.matMul(centeredMatrix, basisMatrix);
                const reconstruction = tf.matMul(scores, basisMatrix.transpose());
                const result = reconstruction.add(mean);
                
                console.log(`[${channel}] Реконструкция завершена`);
                return result.mul(255.0).clipByValue(0, 255);
            });
        }

        let processingTimeout = null;

        function resizeImage(img, maxSize) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            let width = img.width;
            let height = img.height;
            
            if (width > height && width > maxSize) {
                height = Math.round(height * (maxSize / width));
                width = maxSize;
            } else if (height > maxSize) {
                width = Math.round(width * (maxSize / height));
                height = maxSize;
            }
            
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            tempCtx.drawImage(img, 0, 0, width, height);
            
            return tempCtx.getImageData(0, 0, width, height);
        }

        async function compressImage(img, singularValues) {
            try {
                const width = originalCanvas.width;
                const height = originalCanvas.height;
                console.log('Размеры изображения:', { width, height });
                
                const ctx = originalCanvas.getContext('2d', { willReadFrequently: true });
                const imageData = ctx.getImageData(0, 0, width, height);
                
                if (!svdResults.R.V.length) {
                    updateLoadingStatus('Разделение изображения на RGB каналы...');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const [r, g, b] = separateChannels(imageData);
                    
                    updateLoadingStatus('Нормализация данных...');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const rTensor = tf.tensor2d(r, [height, width]);
                    const gTensor = tf.tensor2d(g, [height, width]);
                    const bTensor = tf.tensor2d(b, [height, width]);

                    const [rInit, gInit, bInit] = await Promise.all([
                        performInitialSVD(rTensor, 'R'),
                        performInitialSVD(gTensor, 'G'),
                        performInitialSVD(bTensor, 'B')
                    ]);

                    const maxK = Math.min(50, Math.min(width, height));
                    
                    for (let i = 0; i < maxK; i++) {
                        updateLoadingStatus(`Вычисление компоненты ${i + 1} из ${maxK}...`);
                        
                        await Promise.all([
                            computeNextComponent('R', rInit.covMatrix, rInit.shape),
                            computeNextComponent('G', gInit.covMatrix, gInit.shape),
                            computeNextComponent('B', bInit.covMatrix, bInit.shape)
                        ]);

                        const currentK = i + 1;
                        const singularValuesInput = document.getElementById('singularValues');
                        const singularValuesDisplay = document.getElementById('singularValuesDisplay');
                        const t = translations[currentLanguage];

                        singularValuesInput.value = currentK;
                        singularValuesDisplay.textContent = `${currentK} ${t.componentsOf} ${maxK}`;
                        
                        await updateCompressedImage(currentK);
                        
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }

                    document.getElementById('loadingIndicator').style.display = 'none';
                } else {
                    await updateCompressedImage(singularValues);
                }

            } catch (error) {
                console.error('Ошибка при сжатии:', error);
                updateLoadingStatus('Ошибка при обработке изображения');
            }
        }

        function separateChannels(imageData) {
            const r = new Float32Array(imageData.width * imageData.height);
            const g = new Float32Array(imageData.width * imageData.height);
            const b = new Float32Array(imageData.width * imageData.height);
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const idx = i / 4;
                    r[idx] = imageData.data[i];
                    g[idx] = imageData.data[i + 1];
                    b[idx] = imageData.data[i + 2];
                }

            return [r, g, b];
        }

        function visualizeMatrix(canvas, dataR, dataG, dataB, width, height, fullWidth, fullHeight, drawBorder = false) {
            canvas.width = fullWidth;
            canvas.height = fullHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, fullWidth, fullHeight);
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            const imageData = tempCtx.createImageData(width, height);
            
            let min = Infinity;
            let max = -Infinity;
            for (let i = 0; i < dataR.length; i++) {
                min = Math.min(min, dataR[i], dataG[i], dataB[i]);
                max = Math.max(max, dataR[i], dataG[i], dataB[i]);
            }
            
            for (let i = 0; i < dataR.length; i++) {
                const normalizedR = (dataR[i] - min) / (max - min);
                const normalizedG = (dataG[i] - min) / (max - min);
                const normalizedB = (dataB[i] - min) / (max - min);
                
                const idx = i * 4;
                imageData.data[idx] = Math.round(normalizedR * 255);
                imageData.data[idx + 1] = Math.round(normalizedG * 255);
                imageData.data[idx + 2] = Math.round(normalizedB * 255);
                imageData.data[idx + 3] = 255;
            }
            
            tempCtx.putImageData(imageData, 0, 0);
            
            ctx.drawImage(tempCanvas, 0, 0);

            if (drawBorder) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, fullWidth, fullHeight);

                ctx.strokeStyle = '#666';
                ctx.setLineDash([2, 2]);
                ctx.strokeRect(0, 0, width, height);
                
                if (fullWidth === fullHeight) {
                    ctx.beginPath();
                    ctx.setLineDash([2, 2]);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(fullWidth, fullHeight);
                    ctx.stroke();
                }
            }
        }

        async function visualizeSVDMatrices(k) {
            const { V: VR, centeredMatrix: centeredMatrixR } = svdResults.R;
            const { V: VG, centeredMatrix: centeredMatrixG } = svdResults.G;
            const { V: VB, centeredMatrix: centeredMatrixB } = svdResults.B;
            
            if (!VR.length) return;

            const height = centeredMatrixR.shape[0];
            const width = centeredMatrixR.shape[1];
            const maxK = Math.min(50, Math.min(width, height));

            const processChannel = async (V, centeredMatrix) => {
                const components = V.slice(0, k);
                const basisMatrix = tf.concat(components, 1);
                
                const U = tf.matMul(centeredMatrix, basisMatrix);
                
                const sigma = await Promise.all(components.map(async (v) => {
                    const norm = await tf.norm(tf.matMul(centeredMatrix, v)).array();
                    return norm;
                }));

                const uData = await U.array();
                const vData = await tf.concat(components, 1).transpose().array();

                return {
                    U: uData.flat(),
                    sigma,
                    V: vData.flat()
                };
            };

            const [dataR, dataG, dataB] = await Promise.all([
                processChannel(VR, centeredMatrixR),
                processChannel(VG, centeredMatrixG),
                processChannel(VB, centeredMatrixB)
            ]);

            const uCanvas = document.getElementById('uMatrixCanvas');
            const sigmaCanvas = document.getElementById('sigmaMatrixCanvas');
            const vCanvas = document.getElementById('vMatrixCanvas');

            visualizeMatrix(uCanvas, dataR.U, dataG.U, dataB.U, k, height, maxK, height, true);
            
            const sigmaSize = k;
            const sigmaMatrixR = new Float32Array(sigmaSize * sigmaSize);
            const sigmaMatrixG = new Float32Array(sigmaSize * sigmaSize);
            const sigmaMatrixB = new Float32Array(sigmaSize * sigmaSize);
            
            for (let i = 0; i < k; i++) {
                sigmaMatrixR[i * sigmaSize + i] = dataR.sigma[i];
                sigmaMatrixG[i * sigmaSize + i] = dataG.sigma[i];
                sigmaMatrixB[i * sigmaSize + i] = dataB.sigma[i];
            }
            
            visualizeMatrix(sigmaCanvas, sigmaMatrixR, sigmaMatrixG, sigmaMatrixB, 
                k, k, maxK, maxK, true);
            
            visualizeMatrix(vCanvas, dataR.V, dataG.V, dataB.V, width, k, width, maxK, true);

            function updateDimensions(elementId, width, height, fullWidth, fullHeight) {
                const dimensionsDiv = document.getElementById(elementId);
                if (elementId === 'sigmaDimensions') {
                    dimensionsDiv.innerHTML = `${width}`;
                } else {
                    dimensionsDiv.innerHTML = `${height}×${width}`;
                }
            }

            updateDimensions('uDimensions', k, height, maxK, height);
            updateDimensions('sigmaDimensions', k, k, maxK, maxK);
            updateDimensions('vDimensions', width, k, width, maxK);
        }
    </script>
</body>
</html>

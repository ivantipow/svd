<!DOCTYPE html>
<html>
<head>
    <title>SVD Image Compression</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        .container {
            margin: 20px;
        }
        .images {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .control-panel {
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="loadingIndicator" style="display: none; color: red; margin: 10px 0;">
        Выполняется сжатие изображения...
    </div>
    <div id="progressContainer" style="display: none; margin: 10px 0;">
        <div style="margin-bottom: 5px;">
            <span id="progressStatus">Подготовка...</span>
            <span id="progressPercent">0%</span>
        </div>
        <div style="width: 100%; background-color: #f0f0f0; border-radius: 4px;">
            <div id="progressBar" style="width: 0%; height: 20px; background-color: #4CAF50; border-radius: 4px; transition: width 0.3s;"></div>
        </div>
    </div>
    <div class="container">
        <div class="control-panel">
            <div>
                <input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(event)">
            </div>
            
            <div style="margin-top: 10px;">
                <label for="singularValues">Количество собственных значений: </label>
                <input type="range" id="singularValues" min="1" max="100" value="10" step="1">
                <span id="singularValuesDisplay">10 компонент</span>
            </div>
        </div>

        <div class="images">
            <div>
                <h3>Оригинальное изображение</h3>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div>
                <h3>Сжатое изображение</h3>
                <canvas id="compressedCanvas"></canvas>
            </div>
        </div>
        <img id="originalImage" style="display: none;">
    </div>

    <script>
        // Инициализация элементов после загрузки DOM
        document.addEventListener('DOMContentLoaded', function() {
            const singularValuesInput = document.getElementById('singularValues');
            const singularValuesDisplay = document.getElementById('singularValuesDisplay');
            
            let compressTimeout = null;
            
            function updateSliderMax(width, height) {
                const maxComponents = Math.min(width, height);
                singularValuesInput.max = maxComponents;
                singularValuesInput.value = 20;
                singularValuesDisplay.textContent = `20 из ${maxComponents}`;
                console.log(`Максимальное количество компонент: ${maxComponents}`);
            }
            
            const originalImage = document.getElementById('originalImage');
            originalImage.onload = function() {
                const width = this.width;
                const height = this.height;
                updateSliderMax(width, height);
                drawOriginalImage(this);
                compressImage(this, 20);
            };
            
            // Добавляем debouncing для обработчика слайдера
            singularValuesInput.addEventListener('input', function() {
                const value = parseInt(this.value);
                const max = parseInt(this.max);
                singularValuesDisplay.textContent = `${value} из ${max}`;
                
                // Отменяем предыдущий таймаут
                if (compressTimeout) {
                    clearTimeout(compressTimeout);
                }
                
                // Устанавливаем новый таймаут
                compressTimeout = setTimeout(() => {
                    const img = document.getElementById('originalImage');
                    if (img.src) {
                        compressImage(img, value);
                    }
                }, 100); // Задержка 100мс
            });
        });

        // Остальной код без изменений
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.getElementById('originalImage');
                    img.onload = function() {
                        drawOriginalImage(img);
                        const singularValues = parseInt(document.getElementById('singularValues').value);
                        compressImage(img, singularValues)
                            .catch(error => console.error('Ошибка при сжатии:', error));
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        function drawOriginalImage(img) {
            // Ограничим максимальный размер изображения
            const maxSize = 400;
            let width = img.width;
            let height = img.height;
            
            if (width > maxSize || height > maxSize) {
                const ratio = Math.min(maxSize / width, maxSize / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            }
            
            originalCanvas.width = width;
            originalCanvas.height = height;
            // Добавляем флаг willReadFrequently
            const ctx = originalCanvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0, width, height);
        }
        function showCompressionInfo(originalSize, k) {
            const compressionRatio = ((originalSize - k) / originalSize * 100).toFixed(2);
            console.log(`Степень сжатия: ${compressionRatio}%`);
            console.log(`Использовано компонент: ${k}`);
        }

        // Добавим обработчик изменения количества собственных значений
        document.getElementById('singularValues').addEventListener('input', function() {
            const img = document.getElementById('originalImage');
            if (img.src) {  // Если изображение загружено
                compressImage(img, parseInt(this.value))
                    .catch(error => console.error('Ошибка при сжатии:', error));
            }
        });

        function performSVD(matrix, k) {
            return tf.tidy(() => {
                console.time('SVD детали');
                
                console.time('- Нормализация');
                const normalizedMatrix = matrix.div(255.0);
                const mean = normalizedMatrix.mean(0);
                const centeredMatrix = normalizedMatrix.sub(mean);
                console.timeEnd('- Нормализация');
                
                console.time('- Матрица ковариации');
                const covMatrix = tf.matMul(centeredMatrix.transpose(), centeredMatrix).div(matrix.shape[0]);
                console.timeEnd('- Матрица ковариации');
                
                console.time('- Поиск компонент');
                let V = [];
                for (let i = 0; i < k; i++) {
                    let v = tf.randomNormal([matrix.shape[1], 1]);
                    
                    for (let iter = 0; iter < 20; iter++) {
                        v = tf.matMul(covMatrix, v);
                        const norm = tf.norm(v);
                        v = v.div(norm.add(1e-10));
                        
                        if (V.length > 0) {
                            for (let j = 0; j < V.length; j++) {
                                const proj = tf.sum(v.mul(V[j]));
                                v = v.sub(V[j].mul(proj));
                            }
                            const normAfterProj = tf.norm(v);
                            v = v.div(normAfterProj.add(1e-10));
                        }
                    }
                    V.push(v);
                }
                console.timeEnd('- Поиск компонент');
                
                console.time('- Восстановление');
                const basisMatrix = tf.concat(V, 1);
                const scores = tf.matMul(centeredMatrix, basisMatrix);
                const reconstruction = tf.matMul(scores, basisMatrix.transpose());
                const result = reconstruction.add(mean);
                const scaledResult = result.mul(255.0).clipByValue(0, 255);
                console.timeEnd('- Восстановление');
                
                console.timeEnd('SVD детали');
                return scaledResult;
            });
        }

        // Добавляем задержку между обработкой кадров
        let processingTimeout = null;

        function resizeImage(img, maxSize) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Вычисляем новые размеры, сохраняя пропорции
            let width = img.width;
            let height = img.height;
            
            if (width > height && width > maxSize) {
                height = Math.round(height * (maxSize / width));
                width = maxSize;
            } else if (height > maxSize) {
                width = Math.round(width * (maxSize / height));
                height = maxSize;
            }
            
            // Устанавливаем размеры временного canvas
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            // Рисуем уменьшенное изображение
            tempCtx.drawImage(img, 0, 0, width, height);
            
            return tempCtx.getImageData(0, 0, width, height);
        }

        // Функции для работы с прогресс-баром
        function updateProgress(percent, status) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressPercent = document.getElementById('progressPercent');
            const progressStatus = document.getElementById('progressStatus');
            
            progressContainer.style.display = 'block';
            progressBar.style.width = `${percent}%`;
            progressPercent.textContent = `${Math.round(percent)}%`;
            if (status) {
                progressStatus.textContent = status;
            }
        }

        async function compressImage(img, singularValues) {
            const progressSteps = {
                prepare: { percent: 5, message: 'Подготовка данных...' },
                svdR: { percent: 30, message: 'SVD разложение (красный канал)...' },
                svdG: { percent: 55, message: 'SVD разложение (зеленый канал)...' },
                svdB: { percent: 80, message: 'SVD разложение (синий канал)...' },
                results: { percent: 90, message: 'Получение результатов...' },
                drawing: { percent: 100, message: 'Отрисовка изображения...' }
            };

            let rTensor = null, gTensor = null, bTensor = null;

            try {
                updateProgress(0, 'Начало обработки...');
                
                // Подготовка данных
                updateProgress(progressSteps.prepare.percent, progressSteps.prepare.message);
                const width = originalCanvas.width;
                const height = originalCanvas.height;
                
                const ctx = originalCanvas.getContext('2d', { willReadFrequently: true });
                const imageData = ctx.getImageData(0, 0, width, height);
                
                const r = new Float32Array(width * height);
                const g = new Float32Array(width * height);
                const b = new Float32Array(width * height);
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const idx = i / 4;
                    r[idx] = imageData.data[i];
                    g[idx] = imageData.data[i + 1];
                    b[idx] = imageData.data[i + 2];
                }

                rTensor = tf.tensor2d(r, [height, width]);
                gTensor = tf.tensor2d(g, [height, width]);
                bTensor = tf.tensor2d(b, [height, width]);

                const maxComponents = Math.min(singularValues, Math.min(width, height));
                console.log('Используется компонент:', maxComponents);

                // SVD разложение для каждого канала
                updateProgress(progressSteps.svdR.percent, progressSteps.svdR.message);
                const compressedR = await performSVD(rTensor, maxComponents);
                
                updateProgress(progressSteps.svdG.percent, progressSteps.svdG.message);
                const compressedG = await performSVD(gTensor, maxComponents);
                
                updateProgress(progressSteps.svdB.percent, progressSteps.svdB.message);
                const compressedB = await performSVD(bTensor, maxComponents);

                // Получение результатов
                updateProgress(progressSteps.results.percent, progressSteps.results.message);
                const [rArray, gArray, bArray] = await Promise.all([
                    compressedR.array(),
                    compressedG.array(),
                    compressedB.array()
                ]);

                // Отрисовка результата
                updateProgress(progressSteps.drawing.percent, progressSteps.drawing.message);
                compressedCanvas.width = width;
                compressedCanvas.height = height;
                const compressedCtx = compressedCanvas.getContext('2d', { willReadFrequently: true });
                const compressedImageData = compressedCtx.createImageData(width, height);

                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const idx = (i * width + j) * 4;
                        compressedImageData.data[idx] = Math.round(rArray[i][j]);
                        compressedImageData.data[idx + 1] = Math.round(gArray[i][j]);
                        compressedImageData.data[idx + 2] = Math.round(bArray[i][j]);
                        compressedImageData.data[idx + 3] = 255;
                    }
                }

                compressedCtx.putImageData(compressedImageData, 0, 0);

                // Скрываем прогресс-бар после завершения
                setTimeout(() => {
                    document.getElementById('progressContainer').style.display = 'none';
                }, 1000);

            } catch (error) {
                console.error('Ошибка при сжатии:', error);
                updateProgress(100, 'Ошибка при обработке!');
            } finally {
                if (rTensor) rTensor.dispose();
                if (gTensor) gTensor.dispose();
                if (bTensor) bTensor.dispose();
            }
        }
    </script>
</body>
</html>
